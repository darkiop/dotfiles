#!/bin/bash

# enable fzf
# shellcheck source=/dev/null
case $- in
*i*) ;;
*) return ;;
esac

_dotfiles_add_to_path() {
	local dir="$1"
	[[ -d "$dir" ]] || return 0
	case ":${PATH:-}:" in
	*":${dir}:"*) return 0 ;;
	*) export PATH="${PATH:+${PATH}:}${dir}" ;;
	esac
}

# Ensure fzf is reachable even when installed via dotfiles submodule.
if command -v ADD_TO_PATH >/dev/null 2>&1; then
	ADD_TO_PATH "$HOME/.fzf/bin"
	ADD_TO_PATH "$HOME/dotfiles/modules/fzf/bin"
else
	_dotfiles_add_to_path "$HOME/.fzf/bin"
	_dotfiles_add_to_path "$HOME/dotfiles/modules/fzf/bin"
fi

if ! command -v fzf >/dev/null 2>&1; then
	return 0
fi

if [[ -n ${ZSH_VERSION:-} ]]; then
	# Prefer the installer-generated init script if present.
	# `~/.fzf.bash` contains `eval "$(fzf --bash)"` and must not be sourced by zsh.
	if [[ -f ~/.fzf.zsh ]]; then
		source ~/.fzf.zsh
	fi

	# `eval "$(fzf --zsh)"` breaks because backslash-newline continuations in the
	# generated script are consumed by double-quote parsing before `eval` sees them.
	# Source the generated script instead to preserve its exact contents.
	source <(fzf --zsh 2>/dev/null) || true
else
	# bash
	if [[ -f ~/.fzf.bash ]]; then
		source ~/.fzf.bash
	fi

	# Same rationale as above: source the generated script to preserve continuations.
	source <(fzf --bash 2>/dev/null) || true
fi

# fzf (Fuzzy Finder) Options
export FZF_DEFAULT_OPTS='
--height 50% 
--layout=reverse-list 
--margin=0 
--padding=0 
--border=rounded 
--info=inline 
--ansi 
--color=bg+:#313244,bg:#1e1e2e,spinner:#f5e0dc,hl:#f38ba8 
--color=fg:#ffffff,header:#00afff,info:#00afff,pointer:#ff0000 
--color=marker:#ff0000,fg+:#00afff,prompt:#00afff,hl+:#ffffff
'

dotfiles_fzf__flag_enabled() {
	local var_name="$1"
	if type dotfiles_flag_enabled >/dev/null 2>&1; then
		dotfiles_flag_enabled "${var_name}"
		return $?
	fi
	local value=""
	eval "value=\"\${${var_name}:-}\""
	case "${value}" in
	1 | true | TRUE | yes | YES | y | Y | on | ON) return 0 ;;
	0 | false | FALSE | no | NO | n | N | off | OFF | "") return 1 ;;
	*) return 1 ;;
	esac
}

dotfiles_fzf__set_cmd_var() {
	# Usage: dotfiles_fzf__set_cmd_var VAR_NAME preferred fallback
	local var_name="$1"
	local preferred="$2"
	local fallback="$3"

	local resolved=""
	if [[ -n "${preferred}" ]] && command -v "${preferred}" >/dev/null 2>&1; then
		resolved="${preferred}"
	elif [[ -n "${fallback}" ]] && command -v "${fallback}" >/dev/null 2>&1; then
		resolved="${fallback}"
	fi

	[[ -n "${resolved}" ]] || return 0
	# Avoid eval'ing user input: var_name is a constant in this file.
	printf -v "${var_name}" '%s' "${resolved}"
}

dotfiles_fzf__bash_tab_completion_supported() {
	# fzf-tab-completion bash script needs bash 4+ (readarray, exec {var}>)
	[[ -n ${BASH_VERSINFO[0]:-} && ${BASH_VERSINFO[0]} -ge 4 ]]
}

dotfiles_fzf__zsh_tab_completion_supported() {
	# zsh script relies on gawk (or awk with -W interactive)
	if command -v gawk >/dev/null 2>&1; then
		return 0
	fi
	awk -W interactive 'BEGIN{exit 0}' >/dev/null 2>&1
}

# fzf tab-completion (bash + zsh)
# https://github.com/lincheney/fzf-tab-completion
if dotfiles_fzf__flag_enabled DOTFILES_ENABLE_FZF_TAB_COMPLETION; then
	if [[ -n ${BASH_VERSION:-} && -f ~/dotfiles/modules/fzf-tab-completion/bash/fzf-bash-completion.sh ]]; then
		if dotfiles_fzf__bash_tab_completion_supported; then
			# shellcheck source=/dev/null
			source ~/dotfiles/modules/fzf-tab-completion/bash/fzf-bash-completion.sh
		else
			# macOS ships bash 3.2; skip fzf-tab-completion to keep default completion working.
			:
		fi
		# `which` on some systems prints "... not found" to stdout; sanitize command vars.
		dotfiles_fzf__set_cmd_var _fzf_bash_completion_awk gawk awk
		dotfiles_fzf__set_cmd_var _fzf_bash_completion_sed gsed sed
		dotfiles_fzf__set_cmd_var _fzf_bash_completion_egrep rg egrep
		if dotfiles_fzf__bash_tab_completion_supported; then
			# Replace TAB completion with fzf-powered completion.
			bind -x '"\t": fzf_bash_completion' 2>/dev/null || true
		fi
	elif [[ -n ${ZSH_VERSION:-} && -f ~/dotfiles/modules/fzf-tab-completion/zsh/fzf-zsh-completion.sh ]]; then
		if dotfiles_fzf__zsh_tab_completion_supported; then
			# shellcheck source=/dev/null
			source ~/dotfiles/modules/fzf-tab-completion/zsh/fzf-zsh-completion.sh
		else
			bindkey '^I' expand-or-complete 2>/dev/null || true
		fi
		# Ensure zsh completion is initialized (fzf completion depends on _main_complete).
		if ! whence -w _main_complete >/dev/null 2>&1; then
			autoload -Uz compinit
			if ! compinit -d "${HOME}/.zcompdump" 2>/dev/null; then
				compinit -i -d "${HOME}/.zcompdump" 2>/dev/null || true
			fi
			export DOTFILES_ZSH_COMPINIT_DONE=1
		fi
		# `which` on some systems prints "... not found" to stdout; sanitize command vars.
		dotfiles_fzf__set_cmd_var _fzf_bash_completion_awk gawk awk
		dotfiles_fzf__set_cmd_var _fzf_bash_completion_sed gsed sed
		dotfiles_fzf__set_cmd_var _fzf_bash_completion_egrep rg egrep
		if dotfiles_fzf__zsh_tab_completion_supported; then
			# Bind TAB to fzf completion widget (fallback to default if unavailable).
			if whence -w fzf_completion >/dev/null 2>&1; then
				bindkey '^I' fzf_completion 2>/dev/null || true
			else
				bindkey '^I' expand-or-complete 2>/dev/null || true
			fi
		fi
	fi
fi

# load fzf key bindungs
# if [[ -f /usr/share/doc/fzf/examples/key-bindings.bash ]]; then
#   source /usr/share/doc/fzf/examples/key-bindings.bash
# fi
