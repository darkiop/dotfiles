#!/bin/bash

_dot_help_is_enabled() {
	if command -v dotfiles_flag_enabled >/dev/null 2>&1; then
		dotfiles_flag_enabled "$1"
		return $?
	fi
	return 1
}

dot_help() {
	local use_color=0
	if [[ -t 1 ]] && [[ -z ${NO_COLOR:-} ]]; then
		use_color=1
	fi
	DOT_HELP_C_RESET="${COLOR_RESET:-}"
	DOT_HELP_C_HEAD="${COLOR_LIGHT_BLUE:-}"
	DOT_HELP_C_MUTED="${COLOR_BLUE:-}"
	if [[ ${use_color} -eq 1 ]] && [[ -z ${DOT_HELP_C_RESET} ]]; then
		DOT_HELP_C_HEAD=$'\033[36m'
		DOT_HELP_C_MUTED=$'\033[34m'
		DOT_HELP_C_RESET=$'\033[0m'
	fi

	if [[ ${1:-} == "--plain" ]]; then
		shift || true
		printf '%b%s%b\n' "${DOT_HELP_C_HEAD}" "dotfiles help" "${DOT_HELP_C_RESET}"
		printf '%b%s%b\n' "${DOT_HELP_C_HEAD}" "=============" "${DOT_HELP_C_RESET}"
		_dot_help_plain
		return $?
	fi

	if command -v fzf >/dev/null 2>&1 && [[ -t 1 ]]; then
		_dot_help_fzf
		return $?
	fi

	printf '%b%s%b\n' "${DOT_HELP_C_HEAD}" "dotfiles help" "${DOT_HELP_C_RESET}"
	printf '%b%s%b\n' "${DOT_HELP_C_HEAD}" "=============" "${DOT_HELP_C_RESET}"
	_dot_help_plain
}

_dot_help_plain() {
	_dot_help_requires_enabled() {
		local requires_csv="${1:-}"
		[[ -z ${requires_csv} ]] && return 0
		local flag
		if [[ -n ${ZSH_VERSION:-} ]]; then
			local -a _dot_help_flags
			_dot_help_flags=("${(s:,:)requires_csv}")
			for flag in "${_dot_help_flags[@]}"; do
				[[ -z ${flag} ]] && continue
				if ! _dot_help_is_enabled "${flag}"; then
					return 1
				fi
			done
			return 0
		fi
		local IFS=','
		for flag in ${requires_csv}; do
			[[ -z ${flag} ]] && continue
			if ! _dot_help_is_enabled "${flag}"; then
				return 1
			fi
		done
		return 0
	}

	_dot_help_heading() {
		printf '\n%b%s%b\n' "${DOT_HELP_C_HEAD}" "$1" "${DOT_HELP_C_RESET}"
		printf '%b%s%b\n' "${DOT_HELP_C_MUTED}" "-----------------------------" "${DOT_HELP_C_RESET}"
		printf '%-24s %s\n' "NAME" "INFO"
		printf '%-24s %s\n' "------------------------" "----"
	}

	_dot_help_kv() {
		local name="$1"
		local info="$2"
		printf '%-24s %s\n' "${name}" "${info}"
	}

	local json_path="${DOTFILES_DOT_HELP_JSON:-${HOME}/dotfiles/config/dot_help.json}"
	if ! command -v jq >/dev/null 2>&1; then
		printf '%s\n' "dot help: missing dependency: jq"
		printf '%s\n' "Install jq or set DOTFILES_DOT_HELP_JSON to a pre-rendered TSV."
		return 1
	fi
	if [[ ! -f ${json_path} ]]; then
		printf '%s\n' "dot help: missing file: ${json_path}"
		return 1
	fi

	local kind section name desc requires
	while IFS=$'\t' read -r kind section name desc requires; do
		case "${kind}" in
		head)
			_dot_help_heading "${section}"
			;;
		item)
			if _dot_help_requires_enabled "${requires}"; then
				_dot_help_kv "${name}" "${desc}"
			fi
			;;
		esac
	done < <(jq -r '
		("head\tCommands\t\t\t"),
		(.commands[] | ["item","Commands",.name,.desc,((.requires // []) | join(","))] | @tsv),
		("head\tBindings\t\t\t"),
		(.bindings[] | ["item","Bindings",.name,.desc,((.requires // []) | join(","))] | @tsv),
		("head\tNotes\t\t\t"),
		(.notes[] | ["item","Notes",.name,.desc,((.requires // []) | join(","))] | @tsv)
	' "${json_path}")
}

	_dot_help_fzf() {
	_dot_help_requires_enabled() {
		local requires_csv="${1:-}"
		[[ -z ${requires_csv} ]] && return 0
		local flag
		if [[ -n ${ZSH_VERSION:-} ]]; then
			local -a _dot_help_flags
			_dot_help_flags=("${(s:,:)requires_csv}")
			for flag in "${_dot_help_flags[@]}"; do
				[[ -z ${flag} ]] && continue
				if ! _dot_help_is_enabled "${flag}"; then
					return 1
				fi
			done
			return 0
		fi
		local IFS=','
		for flag in ${requires_csv}; do
			[[ -z ${flag} ]] && continue
			if ! _dot_help_is_enabled "${flag}"; then
				return 1
			fi
		done
		return 0
	}

	local items=()
	local json_path="${DOTFILES_DOT_HELP_JSON:-${HOME}/dotfiles/config/dot_help.json}"

	if ! command -v jq >/dev/null 2>&1; then
		printf '%s\n' "dot help: missing dependency: jq"
		return 1
	fi
	if [[ ! -f ${json_path} ]]; then
		printf '%s\n' "dot help: missing file: ${json_path}"
		return 1
	fi

	local name desc details run requires
	while IFS=$'\t' read -r name desc details run requires; do
		if _dot_help_requires_enabled "${requires}"; then
			items+=("${name}"$'\t'"${desc}"$'\t'"${details}"$'\t'"${run}")
		fi
	done < <(jq -r '
		(.commands[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv),
		(.bindings[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv),
		(.notes[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv)
	' "${json_path}")

		local selection cmd run
		selection="$(printf '%s\n' "${items[@]}" \
			| fzf --prompt='dot help> ' --height 60% --reverse \
				--header='enter: run  |  ctrl-c: cancel' \
				--delimiter=$'\t' --with-nth=1,2 --tabstop=24 --preview 'printf "%b\n" {3}' \
				--preview-window 'right:60%:wrap')"
		[[ -n ${selection} ]] || return 0

		local name desc details
		IFS=$'\t' read -r name desc details run <<<"${selection}"

		# Execute selected command in the current shell.
		if [[ -n ${run} ]]; then
			eval "${run}"
			return 0
		fi

		# Notes: open the referenced file path in the user's editor when there is no run target.
		# We treat the 2nd column (desc) as a path (e.g. ~/dotfiles/config/local_dotfiles_settings).
		if [[ -n ${desc} ]]; then
			_dot_help_open_in_editor() {
				local file="$1"
				local editor="${VISUAL:-${EDITOR:-}}"

				if [[ -z ${editor} ]] && command -v sensible-editor >/dev/null 2>&1; then
					editor="sensible-editor"
				fi
				if [[ -z ${editor} ]]; then
					if command -v nano >/dev/null 2>&1; then
						editor="nano"
					else
						editor="vi"
					fi
				fi

				# Split editor command into argv (zsh does not do word-splitting by default).
				if [[ -n ${ZSH_VERSION:-} ]]; then
					local -a argv
					argv=(${(z)editor})
					command "${argv[@]}" -- "${file}"
					return $?
				fi

				local -a argv
				# shellcheck disable=SC2206
				argv=(${editor})
				command "${argv[@]}" -- "${file}"
			}

			local path="${desc}"

			# Normalize broken paths like "/home/user/~/dotfiles/..." by stripping the prefix
			# up to the embedded "~/" and rebuilding from $HOME.
			if [[ ${path} == *"/~/"* ]]; then
				path="${HOME}/${path#*~/}"
			fi

			# Expand "~" and "$HOME" in a predictable way (tilde expansion does not happen inside quotes).
			case "${path}" in
			"~")
				path="${HOME}"
				;;
			"~/"*)
				path="${HOME}${path#\~}"
				;;
			esac
			path="${path//\$HOME/${HOME}}"
			# Collapse accidental double slashes.
			while [[ ${path} == *"//"* ]]; do
				path="${path//\/\//\/}"
			done

			if [[ -e ${path} ]]; then
				_dot_help_open_in_editor "${path}"
				return $?
			fi

			printf '%s\n' "dot help: note target not found: ${path}" >&2
			return 1
		fi
	}

		_dot_help_setup_keybindings() {
			if _dot_help_is_enabled DOTFILES_ENABLE_DOT_HELP_BINDING; then
				# Ctrl+H is often mapped to Backspace depending on terminal settings.
				if [[ -n ${BASH_VERSION:-} ]]; then
					# Use a readline macro (not bind -x), so interactive programs (fzf/editor)
					# work reliably and the prompt redraw remains correct.
					bind '"\C-h":"\C-u dot help\C-m"' 2>/dev/null || true
				fi

				if [[ -n ${ZSH_VERSION:-} ]]; then
					_dot_help_zle_widget() {
						BUFFER="dot help"
						zle accept-line
					}
					zle -N dot-help _dot_help_zle_widget 2>/dev/null || true
					bindkey '^H' dot-help 2>/dev/null || true
				fi
		fi

		if _dot_help_is_enabled DOTFILES_ENABLE_RELOAD_BINDING; then
			# Alt+R -> reload shell rc
			if [[ -n ${BASH_VERSION:-} ]]; then
				# Use a readline macro (not bind -x), so the command runs via the normal
				# command loop and the multi-line prompt redraw works reliably.
				bind '"\er":"\C-u dot reload\C-m"' 2>/dev/null || true
			fi

			if [[ -n ${ZSH_VERSION:-} ]]; then
				_dot_reload_zle_widget() {
					# Run through the normal accept-line flow to avoid prompt redraw issues.
					BUFFER="dot reload"
					zle accept-line
				}
				zle -N dot-reload _dot_reload_zle_widget 2>/dev/null || true
				bindkey '^[r' dot-reload 2>/dev/null || true
			fi
		fi
	}

_dot_help_setup_keybindings

	dot() {
		local cmd="${1:-}"
		shift || true

		case "${cmd}" in
		help | h)
			dot_help "$@"
			;;
		"")
			dot_help
			;;
			*)
			if [[ ${cmd} == "install" || ${cmd} == "i" ]]; then
				local installer="${HOME}/dotfiles/install.sh"
				if [[ ! -f ${installer} ]]; then
					printf '%s\n' "dot install: missing installer: ${installer}" >&2
					return 1
				fi
				command bash "${installer}" "$@"
				return $?
			fi

			if [[ ${cmd} == "update" || ${cmd} == "u" ]]; then
				local repo_dir="${HOME}/dotfiles"
				if [[ ! -d ${repo_dir} ]]; then
					printf '%s\n' "dot update: missing repo dir: ${repo_dir}" >&2
					return 1
				fi
				if ! command -v git >/dev/null 2>&1; then
					printf '%s\n' "dot update: missing dependency: git" >&2
					return 1
				fi
				(
					cd "${repo_dir}" || exit 1
					git pull --ff-only &&
						git submodule update --init --recursive --depth 1
				)
				return $?
			fi

			if [[ ${cmd} == "reload" ]]; then
				local rc=""
				if [[ -n ${BASH_VERSION:-} ]]; then
					rc="${HOME}/.bashrc"
					[[ -f ${rc} ]] || rc="${HOME}/dotfiles/bashrc"
				elif [[ -n ${ZSH_VERSION:-} ]]; then
					rc="${HOME}/.zshrc"
					[[ -f ${rc} ]] || rc="${HOME}/dotfiles/zshrc"
				fi

					if [[ -n ${rc} ]] && [[ -f ${rc} ]]; then
						# Clear screen to make the reload effect obvious.
						if [[ -t 1 ]]; then
							if command -v clear >/dev/null 2>&1; then
								clear
							else
								printf '\033[2J\033[H'
							fi
						fi
						# shellcheck source=/dev/null
						source "${rc}"
						return 0
					fi

				printf '%s\n' "dot reload: could not determine rc file" >&2
				return 1
			fi

			if command -v dot_doctor >/dev/null 2>&1 && [[ ${cmd} == "doctor" ]]; then
				dot_doctor "$@"
				return $?
			fi

			if [[ ${cmd} == "cache" ]]; then
				local cache_cmd="${1:-}"
				shift || true
				case "${cache_cmd}" in
				remove|rm|clear)
					local cache_dir="${HOME}/.cache/dotfiles/motd"
					if [[ -d ${cache_dir} ]]; then
						rm -rf "${cache_dir}"
						printf '%s\n' "Cache removed: ${cache_dir}"
					else
						printf '%s\n' "Cache directory does not exist: ${cache_dir}"
					fi
					return 0
					;;
				"")
					printf '%s\n' "Usage: dot cache remove"
					printf '%s\n' "       dot cache remove  - Remove MOTD widget cache"
					return 0
					;;
				*)
					printf '%s\n' "Unknown cache subcommand: ${cache_cmd}"
					printf '%s\n' "Usage: dot cache remove"
					return 1
					;;
				esac
			fi

			if [[ ${cmd} == "cd" ]]; then
				local repo_dir="${HOME}/dotfiles"
				if [[ ! -d ${repo_dir} ]]; then
					printf '%s\n' "dot cd: directory not found: ${repo_dir}" >&2
					return 1
				fi
				cd "${repo_dir}" || return 1
				return 0
			fi

			if [[ ${cmd} == "modules" || ${cmd} == "mod" ]]; then
				local repo_dir="${HOME}/dotfiles"
				if [[ ! -d ${repo_dir}/.git ]]; then
					printf '%s\n' "dot modules: not a git repository: ${repo_dir}" >&2
					return 1
				fi
				if ! command -v git >/dev/null 2>&1; then
					printf '%s\n' "dot modules: missing dependency: git" >&2
					return 1
				fi

				local use_color=0
				if [[ -t 1 ]] && [[ -z ${NO_COLOR:-} ]]; then
					use_color=1
				fi
				local c_reset="" c_green="" c_yellow="" c_red="" c_muted=""
				if [[ ${use_color} -eq 1 ]]; then
					c_reset=$'\033[0m'
					c_green=$'\033[32m'
					c_yellow=$'\033[33m'
					c_red=$'\033[31m'
					c_muted=$'\033[90m'
				fi

				printf '%s\n' "Submodules in ${repo_dir}:"
				printf '%s\n' ""

				local status_char commit path desc status_icon status_text
				while IFS= read -r line; do
					[[ -z ${line} ]] && continue
					status_char="${line:0:1}"
					line="${line:1}"
					read -r commit path desc <<<"${line}"

					case "${status_char}" in
					" ")
						status_icon="${c_green}✓${c_reset}"
						status_text="synced"
						;;
					"+")
						status_icon="${c_yellow}↑${c_reset}"
						status_text="modified"
						;;
					"-")
						status_icon="${c_red}✗${c_reset}"
						status_text="not initialized"
						;;
					"U")
						status_icon="${c_red}!${c_reset}"
						status_text="merge conflict"
						;;
					*)
						status_icon="?"
						status_text="unknown"
						;;
					esac

					printf '  %s %-28s %s%s%s\n' "${status_icon}" "${path}" "${c_muted}" "${desc}" "${c_reset}"
				done < <(git -C "${repo_dir}" submodule status 2>/dev/null)

				printf '%s\n' ""
				printf '%s\n' "Legend: ${c_green}✓${c_reset} synced  ${c_yellow}↑${c_reset} modified  ${c_red}✗${c_reset} not initialized"
				return 0
			fi

			printf '%s\n' "Unknown subcommand: ${cmd}"
			printf '%s\n' "Usage: dot help | doctor | reload | install | update | cache | cd | modules"
			return 1
			;;
		esac
	}
