#!/bin/bash

_dot_help_is_enabled() {
	if command -v dotfiles_flag_enabled >/dev/null 2>&1; then
		dotfiles_flag_enabled "$1"
		return $?
	fi
	return 1
}

dot_help() {
	local use_color=0
	if [[ -t 1 ]] && [[ -z ${NO_COLOR:-} ]]; then
		use_color=1
	fi
	DOT_HELP_C_RESET="${COLOR_RESET:-}"
	DOT_HELP_C_HEAD="${COLOR_LIGHT_BLUE:-}"
	DOT_HELP_C_MUTED="${COLOR_BLUE:-}"
	if [[ ${use_color} -eq 1 ]] && [[ -z ${DOT_HELP_C_RESET} ]]; then
		DOT_HELP_C_HEAD=$'\033[36m'
		DOT_HELP_C_MUTED=$'\033[34m'
		DOT_HELP_C_RESET=$'\033[0m'
	fi

	if [[ ${1:-} == "--plain" ]]; then
		shift || true
		printf '%b%s%b\n' "${DOT_HELP_C_HEAD}" "dotfiles help" "${DOT_HELP_C_RESET}"
		printf '%b%s%b\n' "${DOT_HELP_C_HEAD}" "=============" "${DOT_HELP_C_RESET}"
		_dot_help_plain
		return $?
	fi

	if command -v fzf >/dev/null 2>&1 && [[ -t 1 ]]; then
		_dot_help_fzf
		return $?
	fi

	printf '%b%s%b\n' "${DOT_HELP_C_HEAD}" "dotfiles help" "${DOT_HELP_C_RESET}"
	printf '%b%s%b\n' "${DOT_HELP_C_HEAD}" "=============" "${DOT_HELP_C_RESET}"
	_dot_help_plain
}

_dot_help_plain() {
	_dot_help_requires_enabled() {
		local requires_csv="${1:-}"
		[[ -z ${requires_csv} ]] && return 0
		local flag
		IFS=',' read -r -a _dot_help_flags <<<"${requires_csv}"
		for flag in "${_dot_help_flags[@]}"; do
			[[ -z ${flag} ]] && continue
			if ! _dot_help_is_enabled "${flag}"; then
				return 1
			fi
		done
		return 0
	}

	_dot_help_heading() {
		printf '\n%b%s%b\n' "${DOT_HELP_C_HEAD}" "$1" "${DOT_HELP_C_RESET}"
		printf '%b%s%b\n' "${DOT_HELP_C_MUTED}" "-----------------------------" "${DOT_HELP_C_RESET}"
		printf '%-24s %s\n' "NAME" "INFO"
		printf '%-24s %s\n' "------------------------" "----"
	}

	_dot_help_kv() {
		local name="$1"
		local info="$2"
		printf '%-24s %s\n' "${name}" "${info}"
	}

	local json_path="${DOTFILES_DOT_HELP_JSON:-${HOME}/dotfiles/config/dot_help.json}"
	if ! command -v jq >/dev/null 2>&1; then
		printf '%s\n' "dot help: missing dependency: jq"
		printf '%s\n' "Install jq or set DOTFILES_DOT_HELP_JSON to a pre-rendered TSV."
		return 1
	fi
	if [[ ! -f ${json_path} ]]; then
		printf '%s\n' "dot help: missing file: ${json_path}"
		return 1
	fi

	local kind section name desc requires
	while IFS=$'\t' read -r kind section name desc requires; do
		case "${kind}" in
		head)
			_dot_help_heading "${section}"
			;;
		item)
			if _dot_help_requires_enabled "${requires}"; then
				_dot_help_kv "${name}" "${desc}"
			fi
			;;
		esac
	done < <(jq -r '
		("head\tCommands\t\t\t"),
		(.commands[] | ["item","Commands",.name,.desc,((.requires // []) | join(","))] | @tsv),
		("head\tBindings\t\t\t"),
		(.bindings[] | ["item","Bindings",.name,.desc,((.requires // []) | join(","))] | @tsv),
		("head\tNotes\t\t\t"),
		(.notes[] | ["item","Notes",.name,.desc,((.requires // []) | join(","))] | @tsv)
	' "${json_path}")
}

_dot_help_fzf() {
	_dot_help_requires_enabled() {
		local requires_csv="${1:-}"
		[[ -z ${requires_csv} ]] && return 0
		local flag
		IFS=',' read -r -a _dot_help_flags <<<"${requires_csv}"
		for flag in "${_dot_help_flags[@]}"; do
			[[ -z ${flag} ]] && continue
			if ! _dot_help_is_enabled "${flag}"; then
				return 1
			fi
		done
		return 0
	}

	local items=()
	local json_path="${DOTFILES_DOT_HELP_JSON:-${HOME}/dotfiles/config/dot_help.json}"

	if ! command -v jq >/dev/null 2>&1; then
		printf '%s\n' "dot help: missing dependency: jq"
		return 1
	fi
	if [[ ! -f ${json_path} ]]; then
		printf '%s\n' "dot help: missing file: ${json_path}"
		return 1
	fi

	local name desc details run requires
	while IFS=$'\t' read -r name desc details run requires; do
		if _dot_help_requires_enabled "${requires}"; then
			items+=("${name}"$'\t'"${desc}"$'\t'"${details}"$'\t'"${run}")
		fi
	done < <(jq -r '
		(.commands[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv),
		(.bindings[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv),
		(.notes[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv)
	' "${json_path}")

	local selection cmd run
	selection="$(printf '%s\n' "${items[@]}" \
		| fzf --prompt='dot help> ' --height 60% --reverse \
			--header='enter: run  |  ctrl-c: cancel' \
			--delimiter=$'\t' --with-nth=1,2 --tabstop=24 --preview 'printf "%b\n" {3}' \
			--preview-window 'right:60%:wrap')"
	[[ -n ${selection} ]] || return 0

	cmd="${selection%%$'\t'*}"
	run="${selection##*$'\t'}"

	# Execute selected command in the current shell.
	if [[ -n ${run} ]]; then
		eval "${run}"
	fi
}

_dot_help_setup_keybindings() {
	if ! _dot_help_is_enabled DOTFILES_ENABLE_DOT_HELP_BINDING; then
		return 0
	fi

	# Ctrl+H is often mapped to Backspace depending on terminal settings.
	# This binding is opt-in via DOTFILES_ENABLE_DOT_HELP_BINDING.
	if [[ -n ${BASH_VERSION:-} ]]; then
		# Use bind -x so we don't have to inject text into the line editor.
		bind -x '"\C-h":"dot help"' 2>/dev/null || true
	fi

	if [[ -n ${ZSH_VERSION:-} ]]; then
		_dot_help_zle_widget() {
			dot help
			zle reset-prompt
		}
		zle -N dot-help  _dot_help_zle_widget 2>/dev/null || true
		bindkey '^H' dot-help 2>/dev/null || true
	fi
}

_dot_help_setup_keybindings

dot() {
	local cmd="${1:-}"
	shift || true

	case "${cmd}" in
	help)
		dot_help "$@"
		;;
	"")
		dot_help
		;;
	*)
		if command -v dot_doctor >/dev/null 2>&1 && [[ ${cmd} == "doctor" ]]; then
			dot_doctor "$@"
			return $?
		fi
		printf '%s\n' "Unknown subcommand: ${cmd}"
		printf '%s\n' "Usage: dot help | dot doctor"
		return 1
		;;
	esac
}
