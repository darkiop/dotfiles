#!/bin/bash

_dot_help_is_enabled() {
	if command -v dotfiles_flag_enabled >/dev/null 2>&1; then
		dotfiles_flag_enabled "$1"
		return $?
	fi
	return 1
}

dot_help() {
	local use_color=0
	if [[ -t 1 ]] && [[ -z ${NO_COLOR:-} ]]; then
		use_color=1
	fi
	DOT_HELP_C_RESET="${COLOR_RESET:-}"
	DOT_HELP_C_HEAD="${COLOR_LIGHT_BLUE:-}"
	DOT_HELP_C_MUTED="${COLOR_BLUE:-}"
	if [[ ${use_color} -eq 1 ]] && [[ -z ${DOT_HELP_C_RESET} ]]; then
		DOT_HELP_C_HEAD=$'\033[36m'
		DOT_HELP_C_MUTED=$'\033[34m'
		DOT_HELP_C_RESET=$'\033[0m'
	fi

	if [[ ${1:-} == "--plain" ]]; then
		shift || true
		_dot_help_plain
		return $?
	fi

	if command -v fzf >/dev/null 2>&1 && [[ -t 1 ]]; then
		_dot_help_fzf
		return $?
	fi

	_dot_help_plain
}

_dot_help_plain() {
	_dot_help_requires_enabled() {
		local requires_csv="${1:-}"
		[[ -z ${requires_csv} ]] && return 0
		local flag
		if [[ -n ${ZSH_VERSION:-} ]]; then
			local -a _dot_help_flags
			_dot_help_flags=("${(s:,:)requires_csv}")
			for flag in "${_dot_help_flags[@]}"; do
				[[ -z ${flag} ]] && continue
				if ! _dot_help_is_enabled "${flag}"; then
					return 1
				fi
			done
			return 0
		fi
		local IFS=','
		for flag in ${requires_csv}; do
			[[ -z ${flag} ]] && continue
			if ! _dot_help_is_enabled "${flag}"; then
				return 1
			fi
		done
		return 0
	}

	local json_path="${DOTFILES_DOT_HELP_JSON:-${HOME}/dotfiles/config/dot_help.json}"
	if ! command -v jq >/dev/null 2>&1; then
		printf '%s\n' "dot help: missing dependency: jq"
		printf '%s\n' "Install jq or set DOTFILES_DOT_HELP_JSON to a pre-rendered TSV."
		return 1
	fi
	if [[ ! -f ${json_path} ]]; then
		printf '%s\n' "dot help: missing file: ${json_path}"
		return 1
	fi

	# Box drawing characters
	local box_tl="╭" box_tr="╮" box_bl="╰" box_br="╯" box_h="─" box_v="│"
	local tree_mid="├─" tree_end="╰─"

	# Header box
	local title="dotfiles help"
	local box_width=50
	local padding=$(( (box_width - ${#title} - 2) ))
	local pad_left=$(( padding / 2 ))
	local pad_right=$(( padding - pad_left ))

	printf '%b%s' "${DOT_HELP_C_MUTED}" "${box_tl}"
	printf '%0.s─' $(seq 1 $box_width)
	printf '%s%b\n' "${box_tr}" "${DOT_HELP_C_RESET}"

	printf '%b%s%b' "${DOT_HELP_C_MUTED}" "${box_v}" "${DOT_HELP_C_RESET}"
	printf '%*s' "$pad_left" ""
	printf '%b%s%b' "${DOT_HELP_C_HEAD}" " ${title} " "${DOT_HELP_C_RESET}"
	printf '%*s' "$pad_right" ""
	printf '%b%s%b\n' "${DOT_HELP_C_MUTED}" "${box_v}" "${DOT_HELP_C_RESET}"

	printf '%b%s' "${DOT_HELP_C_MUTED}" "${box_bl}"
	printf '%0.s─' $(seq 1 $box_width)
	printf '%s%b\n' "${box_br}" "${DOT_HELP_C_RESET}"

	# Collect items per section (sorted alphabetically)
	local -a commands_items=() bindings_items=() configs_items=()
	local name desc requires

	while IFS=$'\t' read -r name desc requires; do
		if _dot_help_requires_enabled "${requires}"; then
			commands_items+=("${name}"$'\t'"${desc}")
		fi
	done < <(jq -r '.commands | sort_by(.name | ascii_downcase)[] | [.name, .desc, ((.requires // []) | join(","))] | @tsv' "${json_path}")

	while IFS=$'\t' read -r name desc requires; do
		if _dot_help_requires_enabled "${requires}"; then
			bindings_items+=("${name}"$'\t'"${desc}")
		fi
	done < <(jq -r '.bindings | sort_by(.name | ascii_downcase)[] | [.name, .desc, ((.requires // []) | join(","))] | @tsv' "${json_path}")

	while IFS=$'\t' read -r name desc requires; do
		if _dot_help_requires_enabled "${requires}"; then
			configs_items+=("${name}"$'\t'"${desc}")
		fi
	done < <(jq -r '.notes | sort_by(.name | ascii_downcase)[] | [.name, .desc, ((.requires // []) | join(","))] | @tsv' "${json_path}")

	# Print section helper
	_dot_help_print_section() {
		local section_name="$1"
		shift
		local -a items=("$@")
		local count=${#items[@]}
		local i=0

		printf '\n%b%s%b\n' "${DOT_HELP_C_HEAD}" "${section_name}" "${DOT_HELP_C_RESET}"

		for item in "${items[@]}"; do
			i=$((i + 1))
			local item_name item_desc
			IFS=$'\t' read -r item_name item_desc <<< "${item}"
			local prefix="${tree_mid}"
			[[ $i -eq $count ]] && prefix="${tree_end}"
			printf '%b%s%b %-20s %b%s%b\n' \
				"${DOT_HELP_C_MUTED}" "${prefix}" "${DOT_HELP_C_RESET}" \
				"${item_name}" \
				"${DOT_HELP_C_MUTED}" "${item_desc}" "${DOT_HELP_C_RESET}"
		done
	}

	# Print all sections
	if [[ ${#commands_items[@]} -gt 0 ]]; then
		_dot_help_print_section "Commands" "${commands_items[@]}"
	fi
	if [[ ${#bindings_items[@]} -gt 0 ]]; then
		_dot_help_print_section "Bindings" "${bindings_items[@]}"
	fi
	if [[ ${#configs_items[@]} -gt 0 ]]; then
		_dot_help_print_section "Configs" "${configs_items[@]}"
	fi

	printf '\n'
}

	_dot_help_fzf() {
	_dot_help_requires_enabled() {
		local requires_csv="${1:-}"
		[[ -z ${requires_csv} ]] && return 0
		local flag
		if [[ -n ${ZSH_VERSION:-} ]]; then
			local -a _dot_help_flags
			_dot_help_flags=("${(s:,:)requires_csv}")
			for flag in "${_dot_help_flags[@]}"; do
				[[ -z ${flag} ]] && continue
				if ! _dot_help_is_enabled "${flag}"; then
					return 1
				fi
			done
			return 0
		fi
		local IFS=','
		for flag in ${requires_csv}; do
			[[ -z ${flag} ]] && continue
			if ! _dot_help_is_enabled "${flag}"; then
				return 1
			fi
		done
		return 0
	}

	local items=()
	local json_path="${DOTFILES_DOT_HELP_JSON:-${HOME}/dotfiles/config/dot_help.json}"

	if ! command -v jq >/dev/null 2>&1; then
		printf '%s\n' "dot help: missing dependency: jq"
		return 1
	fi
	if [[ ! -f ${json_path} ]]; then
		printf '%s\n' "dot help: missing file: ${json_path}"
		return 1
	fi

	local name desc details run requires
	while IFS=$'\t' read -r name desc details run requires; do
		if _dot_help_requires_enabled "${requires}"; then
			items+=("${name}"$'\t'"${desc}"$'\t'"${details}"$'\t'"${run}")
		fi
	done < <(jq -r '
		(.commands | sort_by(.name | ascii_downcase)[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv),
		(.bindings | sort_by(.name | ascii_downcase)[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv),
		(.notes | sort_by(.name | ascii_downcase)[] | [.name, .desc, .details, (.run // ""), ((.requires // []) | join(","))] | @tsv)
	' "${json_path}")

		local selection cmd run
		selection="$(printf '%s\n' "${items[@]}" \
			| fzf --prompt='dot help> ' --height 60% --reverse \
				--header='enter: run  |  ctrl-c: cancel' \
				--delimiter=$'\t' --with-nth=1,2 --tabstop=24 --preview 'printf "%b\n" {3}' \
				--preview-window 'right:60%:wrap')"
		[[ -n ${selection} ]] || return 0

		local name desc details
		IFS=$'\t' read -r name desc details run <<<"${selection}"

		# Execute selected command in the current shell.
		if [[ -n ${run} ]]; then
			eval "${run}"
			return 0
		fi

		# Notes: open the referenced file path in the user's editor when there is no run target.
		# We treat the 2nd column (desc) as a path (e.g. ~/dotfiles/config/local_dotfiles_settings).
		if [[ -n ${desc} ]]; then
			_dot_help_open_in_editor() {
				local file="$1"
				local editor="${VISUAL:-${EDITOR:-}}"

				if [[ -z ${editor} ]] && command -v sensible-editor >/dev/null 2>&1; then
					editor="sensible-editor"
				fi
				if [[ -z ${editor} ]]; then
					if command -v nano >/dev/null 2>&1; then
						editor="nano"
					else
						editor="vi"
					fi
				fi

				# Split editor command into argv (zsh does not do word-splitting by default).
				if [[ -n ${ZSH_VERSION:-} ]]; then
					local -a argv
					argv=(${(z)editor})
					command "${argv[@]}" -- "${file}"
					return $?
				fi

				local -a argv
				# shellcheck disable=SC2206
				argv=(${editor})
				command "${argv[@]}" -- "${file}"
			}

			local path="${desc}"

			# Normalize broken paths like "/home/user/~/dotfiles/..." by stripping the prefix
			# up to the embedded "~/" and rebuilding from $HOME.
			if [[ ${path} == *"/~/"* ]]; then
				path="${HOME}/${path#*~/}"
			fi

			# Expand "~" and "$HOME" in a predictable way (tilde expansion does not happen inside quotes).
			case "${path}" in
			"~")
				path="${HOME}"
				;;
			"~/"*)
				path="${HOME}${path#\~}"
				;;
			esac
			path="${path//\$HOME/${HOME}}"
			# Collapse accidental double slashes.
			while [[ ${path} == *"//"* ]]; do
				path="${path//\/\//\/}"
			done

			if [[ -e ${path} ]]; then
				_dot_help_open_in_editor "${path}"
				return $?
			fi

			printf '%s\n' "dot help: note target not found: ${path}" >&2
			return 1
		fi
	}

		_dot_help_setup_keybindings() {
			if _dot_help_is_enabled DOTFILES_ENABLE_DOT_HELP_BINDING; then
				# Ctrl+H is often mapped to Backspace depending on terminal settings.
				if [[ -n ${BASH_VERSION:-} ]]; then
					# Use a readline macro (not bind -x), so interactive programs (fzf/editor)
					# work reliably and the prompt redraw remains correct.
					bind '"\C-h":"\C-u dot help\C-m"' 2>/dev/null || true
				fi

				if [[ -n ${ZSH_VERSION:-} ]]; then
					_dot_help_zle_widget() {
						BUFFER="dot help"
						zle accept-line
					}
					zle -N dot-help _dot_help_zle_widget 2>/dev/null || true
					bindkey '^H' dot-help 2>/dev/null || true
				fi
		fi

		if _dot_help_is_enabled DOTFILES_ENABLE_RELOAD_BINDING; then
			# Alt+R -> reload shell rc
			if [[ -n ${BASH_VERSION:-} ]]; then
				# Use a readline macro (not bind -x), so the command runs via the normal
				# command loop and the multi-line prompt redraw works reliably.
				bind '"\er":"\C-u dot reload\C-m"' 2>/dev/null || true
			fi

			if [[ -n ${ZSH_VERSION:-} ]]; then
				_dot_reload_zle_widget() {
					# Run through the normal accept-line flow to avoid prompt redraw issues.
					BUFFER="dot reload"
					zle accept-line
				}
				zle -N dot-reload _dot_reload_zle_widget 2>/dev/null || true
				bindkey '^[r' dot-reload 2>/dev/null || true
			fi
		fi
	}

_dot_help_setup_keybindings

	dot() {
		local cmd="${1:-}"
		shift || true

		case "${cmd}" in
		help | h)
			dot_help "$@"
			;;
		"")
			dot_help
			;;
			*)
			if [[ ${cmd} == "install" || ${cmd} == "i" ]]; then
				local installer="${HOME}/dotfiles/install.sh"
				if [[ ! -f ${installer} ]]; then
					printf '%s\n' "dot install: missing installer: ${installer}" >&2
					return 1
				fi
				command bash "${installer}" "$@"
				return $?
			fi

			if [[ ${cmd} == "update" || ${cmd} == "u" ]]; then
				local repo_dir="${HOME}/dotfiles"
				if [[ ! -d ${repo_dir} ]]; then
					printf '%s\n' "dot update: missing repo dir: ${repo_dir}" >&2
					return 1
				fi
				if ! command -v git >/dev/null 2>&1; then
					printf '%s\n' "dot update: missing dependency: git" >&2
					return 1
				fi
				(
					cd "${repo_dir}" || exit 1
					git pull --ff-only &&
						git submodule update --init --recursive --depth 1
				)
				return $?
			fi

			if [[ ${cmd} == "reload" ]]; then
				local rc=""
				if [[ -n ${BASH_VERSION:-} ]]; then
					rc="${HOME}/.bashrc"
					[[ -f ${rc} ]] || rc="${HOME}/dotfiles/bashrc"
				elif [[ -n ${ZSH_VERSION:-} ]]; then
					rc="${HOME}/.zshrc"
					[[ -f ${rc} ]] || rc="${HOME}/dotfiles/zshrc"
				fi

					if [[ -n ${rc} ]] && [[ -f ${rc} ]]; then
						# Clear screen to make the reload effect obvious.
						if [[ -t 1 ]]; then
							if command -v clear >/dev/null 2>&1; then
								clear
							else
								printf '\033[2J\033[H'
							fi
						fi
						# shellcheck source=/dev/null
						source "${rc}"
						return 0
					fi

				printf '%s\n' "dot reload: could not determine rc file" >&2
				return 1
			fi

			if command -v dot_doctor >/dev/null 2>&1 && [[ ${cmd} == "doctor" ]]; then
				dot_doctor "$@"
				return $?
			fi

			if [[ ${cmd} == "profile" || ${cmd} == "prof" ]]; then
				if command -v dot_profile >/dev/null 2>&1; then
					dot_profile "$@"
					return $?
				fi
				# Inline fallback if dot_profile component not loaded
				local profile_comp="${HOME}/dotfiles/components/dot_profile"
				if [[ -f ${profile_comp} ]]; then
					# shellcheck source=/dev/null
					source "${profile_comp}"
					dot_profile "$@"
					return $?
				fi
				printf '%s\n' "dot profile: component not found: ${profile_comp}" >&2
				return 1
			fi

			if [[ ${cmd} == "cache" ]]; then
				local cache_cmd="${1:-}"
				shift || true
				case "${cache_cmd}" in
				remove|rm|clear)
					local cache_dir="${HOME}/.cache/dotfiles/motd"
					if [[ -d ${cache_dir} ]]; then
						rm -rf "${cache_dir}"
						printf '%s\n' "Cache removed: ${cache_dir}"
					else
						printf '%s\n' "Cache directory does not exist: ${cache_dir}"
					fi
					return 0
					;;
				"")
					printf '%s\n' "Usage: dot cache remove"
					printf '%s\n' "       dot cache remove  - Remove MOTD widget cache"
					return 0
					;;
				*)
					printf '%s\n' "Unknown cache subcommand: ${cache_cmd}"
					printf '%s\n' "Usage: dot cache remove"
					return 1
					;;
				esac
			fi

			if [[ ${cmd} == "cd" ]]; then
				local repo_dir="${HOME}/dotfiles"
				if [[ ! -d ${repo_dir} ]]; then
					printf '%s\n' "dot cd: directory not found: ${repo_dir}" >&2
					return 1
				fi
				cd "${repo_dir}" || return 1
				return 0
			fi

			if [[ ${cmd} == "modules" || ${cmd} == "mod" ]]; then
				local repo_dir="${HOME}/dotfiles"
				if [[ ! -d ${repo_dir}/.git ]]; then
					printf '%s\n' "dot modules: not a git repository: ${repo_dir}" >&2
					return 1
				fi
				if ! command -v git >/dev/null 2>&1; then
					printf '%s\n' "dot modules: missing dependency: git" >&2
					return 1
				fi

				local use_color=0
				if [[ -t 1 ]] && [[ -z ${NO_COLOR:-} ]]; then
					use_color=1
				fi
				local c_reset="" c_green="" c_yellow="" c_red="" c_muted=""
				if [[ ${use_color} -eq 1 ]]; then
					c_reset=$'\033[0m'
					c_green=$'\033[32m'
					c_yellow=$'\033[33m'
					c_red=$'\033[31m'
					c_muted=$'\033[90m'
				fi

				printf '%s\n' "Submodules in ${repo_dir}:"
				printf '%s\n' ""

				local status_char commit path desc status_icon status_text
				while IFS= read -r line; do
					[[ -z ${line} ]] && continue
					status_char="${line:0:1}"
					line="${line:1}"
					read -r commit path desc <<<"${line}"

					case "${status_char}" in
					" ")
						status_icon="${c_green}✓${c_reset}"
						status_text="synced"
						;;
					"+")
						status_icon="${c_yellow}↑${c_reset}"
						status_text="modified"
						;;
					"-")
						status_icon="${c_red}✗${c_reset}"
						status_text="not initialized"
						;;
					"U")
						status_icon="${c_red}!${c_reset}"
						status_text="merge conflict"
						;;
					*)
						status_icon="?"
						status_text="unknown"
						;;
					esac

					printf '  %s %-28s %s%s%s\n' "${status_icon}" "${path}" "${c_muted}" "${desc}" "${c_reset}"
				done < <(git -C "${repo_dir}" submodule status 2>/dev/null)

				printf '%s\n' ""
				printf '%s\n' "Legend: ${c_green}✓${c_reset} synced  ${c_yellow}↑${c_reset} modified  ${c_red}✗${c_reset} not initialized"
				return 0
			fi

			if [[ ${cmd} == "env" ]]; then
				local use_color=0
				if [[ -t 1 ]] && [[ -z ${NO_COLOR:-} ]]; then
					use_color=1
				fi
				local c_reset="" c_name="" c_true="" c_false="" c_value=""
				if [[ ${use_color} -eq 1 ]]; then
					c_reset=$'\033[0m'
					c_name=$'\033[36m'
					c_true=$'\033[32m'
					c_false=$'\033[31m'
					c_value=$'\033[33m'
				fi

				printf '%s\n' "DOTFILES_* environment variables:"
				printf '%s\n' ""

				local name value display_value
				while IFS='=' read -r name value; do
					[[ -z ${name} ]] && continue
					if [[ ${value} == "true" ]]; then
						display_value="${c_true}${value}${c_reset}"
					elif [[ ${value} == "false" ]]; then
						display_value="${c_false}${value}${c_reset}"
					else
						display_value="${c_value}${value}${c_reset}"
					fi
					printf "  %s%-35s%s = %s\n" "${c_name}" "${name}" "${c_reset}" "${display_value}"
				done < <(env | grep '^DOTFILES_' | sort)

				local count
				count=$(env | grep -c '^DOTFILES_' || echo 0)
				printf '%s\n' ""
				printf '%s\n' "Total: ${count} variables"
				return 0
			fi

			if [[ ${cmd} == "alias" || ${cmd} == "aliases" ]]; then
				# Use same color scheme as dot help --plain
				local use_color=0
				if [[ -t 1 ]] && [[ -z ${NO_COLOR:-} ]]; then
					use_color=1
				fi
				local c_reset="" c_head="" c_muted="" c_green="" c_red=""
				if [[ ${use_color} -eq 1 ]]; then
					c_reset=$'\033[0m'
					c_head=$'\033[38;5;81m'
					c_muted=$'\033[38;5;39m'
					c_green=$'\033[38;5;83m'
					c_red=$'\033[38;5;196m'
				fi

				local filter="${1:-}"

				# Box drawing characters
				local box_tl="╭" box_tr="╮" box_bl="╰" box_br="╯"
				local title="dot alias"
				local box_width=50
				local padding=$(( (box_width - ${#title} - 2) ))
				local pad_left=$(( padding / 2 ))
				local pad_right=$(( padding - pad_left ))

				printf '%b%s' "${c_muted}" "${box_tl}"
				printf '%0.s─' $(seq 1 $box_width)
				printf '%s%b\n' "${box_tr}" "${c_reset}"

				printf '%b%s%b' "${c_muted}" "│" "${c_reset}"
				printf '%*s' "$pad_left" ""
				printf '%b%s%b' "${c_head}" " ${title} " "${c_reset}"
				printf '%*s' "$pad_right" ""
				printf '%b%s%b\n' "${c_muted}" "│" "${c_reset}"

				printf '%b%s' "${c_muted}" "${box_bl}"
				printf '%0.s─' $(seq 1 $box_width)
				printf '%s%b\n' "${box_br}" "${c_reset}"

				local -a alias_items=()
				local name value
				while IFS= read -r line; do
					# Parse alias output: alias name='value' or alias name=value
					if [[ ${line} =~ ^alias\ ([^=]+)=(.*)$ ]]; then
						name="${BASH_REMATCH[1]}"
						value="${BASH_REMATCH[2]}"
						# Remove surrounding quotes if present
						value="${value#\'}"
						value="${value%\'}"
						value="${value#\"}"
						value="${value%\"}"

						# Apply filter if provided
						if [[ -n ${filter} ]] && [[ ! ${name} == *${filter}* ]] && [[ ! ${value} == *${filter}* ]]; then
							continue
						fi

						# Check if the command is available
						local cmd_check="${value%% *}"  # First word
						cmd_check="${cmd_check#sudo }"  # Strip sudo prefix
						cmd_check="${cmd_check%% *}"    # First word again after sudo
						local status_icon="${c_green}✓${c_reset}"
						if ! command -v "${cmd_check}" >/dev/null 2>&1; then
							status_icon="${c_red}✗${c_reset}"
						fi

						alias_items+=("${status_icon}"$'\t'"${name}"$'\t'"${value}")
					fi
				done < <(alias 2>/dev/null | sort)

				local count=${#alias_items[@]}

				_dot_alias_print_section() {
					local section_name="$1"
					shift
					local -a items=("$@")
					local item_count=${#items[@]}
					local i=0

					printf '\n%b%s%b\n' "${c_head}" "${section_name}" "${c_reset}"
					for item in "${items[@]}"; do
						i=$((i + 1))
						local item_icon item_name item_desc prefix
						IFS=$'\t' read -r item_icon item_name item_desc <<< "${item}"
						prefix="├─"
						[[ $i -eq $item_count ]] && prefix="╰─"
						printf '%b%s%b %s %-24s %b%s%b\n' \
							"${c_muted}" "${prefix}" "${c_reset}" \
							"${item_icon}" \
							"${item_name}" \
							"${c_muted}" "${item_desc}" "${c_reset}"
					done
				}

				if [[ ${count} -gt 0 ]]; then
					_dot_alias_print_section "Aliases" "${alias_items[@]}"
				fi

				printf '\n%b%s%b\n' "${c_head}" "Summary" "${c_reset}"
				if [[ -n ${filter} ]]; then
					printf '%b╰─%b Total: %d aliases (filter: %s)\n' "${c_muted}" "${c_reset}" "${count}" "${filter}"
				else
					printf '%b╰─%b Total: %d aliases  %b│  %s✓%b = available  %s✗%b = not found%b\n' \
						"${c_muted}" "${c_reset}" "${count}" \
						"${c_muted}" "${c_green}" "${c_reset}" "${c_red}" "${c_reset}" "${c_reset}"
				fi

				printf '\n'
				return 0
			fi

			printf '%s\n' "Unknown subcommand: ${cmd}"
			printf '%s\n' "Usage: dot help | doctor | profile | reload | install | update | cache | cd | modules | env | alias"
			return 1
			;;
		esac
	}
