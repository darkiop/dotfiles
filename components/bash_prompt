#!/bin/bash
# https://github.com/koljah-de/simple-bash-prompt/
# https://scriptim.github.io/bash-prompt-generator/
# https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html

# Set prompt colors
COLOR_BRACKET=${COLOR_BLUE}
#COLOR_COMMAND=${COLOR_WHITE}
COLOR_HOST=${COLOR_BLUE}
COLOR_DIR=${COLOR_ORANGE}
COLOR_SEPARATOR=${COLOR_WHITE}
COLOR_DATE=${COLOR_GREEN}
#COLOR_GIT=${COLOR_YELLOW}
COLOR_GIT_BRANCH=${COLOR_YELLOW}
COLOR_SUDO_ACTIVE=${COLOR_PURPLE}
COLOR_SSH_ACTIVE=${COLOR_LIGHT_BLUE}
if [[ ${EUID} -ne 0 ]]; then
	# User != root
	COLOR_USER=${COLOR_LIGHT_BLUE}
	COLOR_SYMBOL=${COLOR_WHITE}
else
	# User = root
	COLOR_USER=${COLOR_RED}
	COLOR_SYMBOL=${COLOR_RED}
fi

# Define the prompt terminator character
SYMBOL="\\$"

# Get the IP
IP=$(
	ip a | grep 'inet' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | grep -v '172' | grep -v '^100.' | head -n 1 || true
)

# Set the color with the exit status of the last command
function COLOR_EXIT_STATUS() {
	if [[ $1 -eq 0 ]]; then
		printf '%s' "${COLOR_BLUE}"
	else
		printf '%s' "${COLOR_RED}"
	fi
}

# Git: check if current directory is a git repo
function CHECK_IF_GIT_REPO() {
	git rev-parse --is-inside-work-tree >/dev/null 2>&1
}

# Git-prompt
# https://jon.sprig.gs/blog/post/1940
function GIT_PROMPT() {
	if ! command -v git >/dev/null 2>&1; then
		return 0
	fi
	if ! type __git_ps1 >/dev/null 2>&1; then
		return 0
	fi

	# options
	# https://blog.backslasher.net/git-prompt-variables.html
	export GIT_PS1_DESCRIBE_STYLE='contains'
	# __git_ps1 can emit unwrapped escape sequences when color hints are enabled,
	# which breaks readline redraws (e.g. when resizing the terminal).
	export GIT_PS1_SHOWCOLORHINTS='n'
	export GIT_PS1_SHOWDIRTYSTATE='y'
	export GIT_PS1_SHOWSTASHSTATE='y'
	export GIT_PS1_SHOWUNTRACKEDFILES='y'
	export GIT_PS1_SHOWUPSTREAM='auto'

	# prompt
	# https://stackoverflow.com/questions/25911546/configure-git-branch-in-prompt
	# staged = + stashed = $ untracked = %
	__git_ps1 'git:%s'
}

# check sudo
function CHECK_IF_SUDO_IS_ACTIVE() {
	if [[ ${EUID} -eq 0 ]]; then
		return 1 # false
	else
		if sudo -vn 2>/dev/null; then
			return 0 # true
		else
			return 1 # false
		fi
	fi
}

# Check if ssh session
function CHECK_IF_SSH_SESSION() {
	if [[ -n ${SSH_CONNECTION} || -n ${SSH_CLIENT} ]]; then
		return 0 # true
	else
		return 1 # false
	fi
}

# Show permissions of current directoy
# %A drwxr-xr-xr-x
# %a 755
function SHOW_PERMISSIONS_OF_CUR_DIR() {
	stat -c %a .
}

# Build the prompt
#
# \n = new line
# \u = user
# \h = time
# \w = current dir
#
function BUILD_PROMPT() {
	local exit_status=$?
	local git_part
	local prompt_style="${DOTFILES_PROMPT_STYLE:-classic}"

	# Some terminal emulators respond to OSC queries (e.g. background color query OSC 11)
	# by writing escape sequences to the pty. If nothing consumes that response, readline
	# can treat it as typed input and it shows up as garbage in the prompt line.
	# Flush pending bytes once per shell start (including slightly delayed responses after tmux attach).
	if [[ -z ${DOTFILES_STDIN_FLUSHED+x} ]]; then
		DOTFILES_STDIN_FLUSHED=1
		local _dotfiles_steps=4
		local _dotfiles_step_wait=0.05
		# tmux attach on login can delay OSC replies noticeably (network / terminal latency).
		[[ -n "${TMUX:-}" ]] && _dotfiles_steps=80

		local _dotfiles_i=0
		local _dotfiles_step=0
		for ((_dotfiles_step = 0; _dotfiles_step < _dotfiles_steps; _dotfiles_step++)); do
			local _dotfiles_drained=0
			while IFS= read -r -t 0 -n 1 _dotfiles_discard; do
				_dotfiles_drained=1
				((_dotfiles_i++ > 2048)) && break
			done

			# Wait briefly for delayed bytes; if nothing arrived and we didn't drain anything, we're done.
			if IFS= read -r -t "${_dotfiles_step_wait}" -n 1 _dotfiles_discard; then
				_dotfiles_drained=1
				continue
			fi
			[[ "${_dotfiles_drained}" -eq 1 ]] || break
		done
	fi

	if [[ ${prompt_style} == "compact" ]]; then
		# Compact style: ┌──(user㉿host)-[dir]
		BASH_PROMPT="\n"
		BASH_PROMPT+="\[$(COLOR_EXIT_STATUS "${exit_status}")\]┌──"
		BASH_PROMPT+="\[$COLOR_BRACKET\]("
		BASH_PROMPT+="\[$COLOR_USER\]\\u"
		BASH_PROMPT+="\[$COLOR_SEPARATOR\]㉿"
		BASH_PROMPT+="\[$COLOR_HOST\]\\h"
		BASH_PROMPT+="\[$COLOR_BRACKET\])-["
		BASH_PROMPT+="\[$COLOR_DIR\]\\w"
		BASH_PROMPT+="\[$COLOR_BRACKET\]]"
	else
		# Classic style: Full info
		BASH_PROMPT="\n"
		BASH_PROMPT+="\[$(COLOR_EXIT_STATUS "${exit_status}")\]┌"
		BASH_PROMPT+="\[$COLOR_BRACKET\]["
		BASH_PROMPT+="\[$COLOR_DATE\]\\t"
		BASH_PROMPT+="\[$COLOR_BRACKET\]]"
		BASH_PROMPT+=" "
		BASH_PROMPT+="\[$COLOR_BRACKET\]["

		if CHECK_IF_SSH_SESSION; then
			BASH_PROMPT+="\[$COLOR_SSH_ACTIVE\]ssh\[$COLOR_SEPARATOR\]:"
		fi

		BASH_PROMPT+="\[$COLOR_USER\]\\u\[$COLOR_SEPARATOR\]㉿\[$COLOR_HOST\]\\h"
		if [[ -n ${IP} ]]; then
			BASH_PROMPT+="\[$COLOR_SEPARATOR\] (\[$COLOR_RESET\]${IP}\[$COLOR_SEPARATOR\])"
		fi
		BASH_PROMPT+="\[$COLOR_SEPARATOR\]: "
		BASH_PROMPT+="\[$COLOR_DIR\]\\w"
		BASH_PROMPT+="\[$COLOR_RESET\] ($(SHOW_PERMISSIONS_OF_CUR_DIR))"
		BASH_PROMPT+="\[$COLOR_BRACKET\]]"
	fi

	if CHECK_IF_GIT_REPO; then
		git_part="$(GIT_PROMPT)"
		if [[ -n ${git_part} ]]; then
			local git_body="$git_part"
			local git_upstream=""
			case "$git_part" in
				*"<>" )
					git_body="${git_part%<>}"
					git_upstream="<>"
					;;
				*">" )
					git_body="${git_part%>}"
					git_upstream=">"
					;;
				*"<" )
					git_body="${git_part%<}"
					git_upstream="<"
					;;
				*"=" )
					git_body="${git_part%=}"
					git_upstream="="
					;;
			esac

			BASH_PROMPT+=" "
			BASH_PROMPT+="\[$COLOR_BRACKET\]["
			BASH_PROMPT+="\[$COLOR_GIT_BRANCH\]${git_body}"
			if [[ -n ${git_upstream} ]]; then
				# Match the git-prompt upstream marker color (ANSI red), so it matches *% etc.
				BASH_PROMPT+="\[\033[31m\]${git_upstream}"
			fi
			BASH_PROMPT+="\[$COLOR_BRACKET\]]"
		fi
	fi

	if CHECK_IF_SUDO_IS_ACTIVE; then
		BASH_PROMPT+=" "
		BASH_PROMPT+="\[$COLOR_BRACKET\]["
		BASH_PROMPT+="\[$COLOR_SUDO_ACTIVE\]sudo"
		BASH_PROMPT+="\[$COLOR_BRACKET\]]"
	fi

	BASH_PROMPT+="\n"
	BASH_PROMPT+="\[$(COLOR_EXIT_STATUS "${exit_status}")\]└─"
	BASH_PROMPT+="\[$COLOR_SYMBOL\]${SYMBOL} "

	BASH_PROMPT+="\[$COLOR_RESET\]"

	PS1=${BASH_PROMPT}
}

# Chain with any existing PROMPT_COMMAND (history sync, etc.) without duplicating.
case ";${PROMPT_COMMAND};" in
*";BUILD_PROMPT;"* | *"; BUILD_PROMPT;"*) ;;
*)
	if [[ -n ${PROMPT_COMMAND} ]]; then
		PROMPT_COMMAND="${PROMPT_COMMAND}; BUILD_PROMPT"
	else
		PROMPT_COMMAND="BUILD_PROMPT"
	fi
	;;
esac

export PROMPT_COMMAND
