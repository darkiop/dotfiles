#!/usr/bin/env zsh

# Prompt for zsh, styled similar to components/bash_prompt (bash).
# Uses zsh-native %F/%f color escapes and avoids non-ASCII source text.

if [[ -z "${ZSH_VERSION:-}" ]]; then
  return 0
fi

case $- in
  *i*) ;;
  *) return ;;
esac

setopt PROMPT_SUBST

DOTFILES_PROMPT_IP="${DOTFILES_PROMPT_IP:-}"

DOTFILES_PROMPT_GIT=""
DOTFILES_PROMPT_GIT_BRANCH=""
DOTFILES_PROMPT_GIT_FLAGS=""
DOTFILES_PROMPT_PERMS=""
DOTFILES_PROMPT_SSH=0
DOTFILES_PROMPT_SUDO=0

dotfiles_prompt_escape_percent() {
  # '%' is special in zsh prompt strings; '%%' renders a literal '%'.
  print -r -- "${1//\%/%%}"
}

dotfiles_prompt_git() {
  command -v git >/dev/null 2>&1 || return 0
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 0

  DOTFILES_PROMPT_GIT_BRANCH=""
  DOTFILES_PROMPT_GIT_FLAGS=""
  DOTFILES_PROMPT_GIT_UPSTREAM=""
  DOTFILES_PROMPT_GIT=""

  local branch staged dirty untracked stashed upstream ahead behind
  branch="$(git symbolic-ref --quiet --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)"

  staged=""; dirty=""; untracked=""; stashed=""
  git diff --cached --quiet 2>/dev/null || staged="+"
  git diff --quiet 2>/dev/null || dirty="*"
  [[ -n "$(git ls-files --others --exclude-standard 2>/dev/null | head -n 1)" ]] && untracked="%"
  git rev-parse --verify refs/stash >/dev/null 2>&1 && stashed="$"

  DOTFILES_PROMPT_GIT_BRANCH="$(dotfiles_prompt_escape_percent "${branch}")"

  # Match bash-like markers ordering: staged (+), dirty (*), stashed ($), untracked (%).
  local flags="${staged}${dirty}${stashed}${untracked}"
  DOTFILES_PROMPT_GIT_FLAGS="$(dotfiles_prompt_escape_percent "${flags}")"

  # Upstream marker (like bash __git_ps1 with GIT_PS1_SHOWUPSTREAM=auto):
  #   '>' ahead, '<' behind, '<>' diverged, '=' equal.
  upstream="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
  if [[ -n "${upstream}" ]]; then
    local counts
    counts="$(git rev-list --left-right --count HEAD...@{u} 2>/dev/null || true)"
    # git uses a tab separator here; normalize whitespace then split.
    counts="${counts//$'\t'/ }"
    counts="${counts//$'\n'/ }"
    local -a parts
    parts=(${=counts})
    ahead="${parts[1]:-0}"
    behind="${parts[2]:-0}"

    if [[ "${ahead}" -gt 0 && "${behind}" -gt 0 ]]; then
      DOTFILES_PROMPT_GIT_UPSTREAM="<>"
    elif [[ "${ahead}" -gt 0 ]]; then
      DOTFILES_PROMPT_GIT_UPSTREAM=">"
    elif [[ "${behind}" -gt 0 ]]; then
      DOTFILES_PROMPT_GIT_UPSTREAM="<"
    else
      DOTFILES_PROMPT_GIT_UPSTREAM="="
    fi
  fi

  # Backwards-compatible full string (used nowhere else, but handy for debugging).
  DOTFILES_PROMPT_GIT="git:${DOTFILES_PROMPT_GIT_BRANCH}${DOTFILES_PROMPT_GIT_FLAGS}${DOTFILES_PROMPT_GIT_UPSTREAM}"
}

dotfiles_prompt_perms() {
  command -v stat >/dev/null 2>&1 || return 0
  stat -c %a . 2>/dev/null || true
}

dotfiles_prompt_ip() {
  # If we're in an SSH session, prefer the server-side IP from SSH_CONNECTION:
  # <client_ip> <client_port> <server_ip> <server_port>
  if [[ -n ${SSH_CONNECTION:-} ]]; then
    local ssh_server_ip="${${(s: :)SSH_CONNECTION}[3]}"
    if [[ -n "${ssh_server_ip}" ]]; then
      print -r -- "${ssh_server_ip}"
      return 0
    fi
  fi

  # Resolve `ip` even if PATH doesn't include /usr/sbin, and ignore aliases.
  local ip_cmd=""
  ip_cmd="${commands[ip]:-}"
  if [[ -z "${ip_cmd}" ]]; then
    if [[ -x /usr/sbin/ip ]]; then
      ip_cmd="/usr/sbin/ip"
    elif [[ -x /sbin/ip ]]; then
      ip_cmd="/sbin/ip"
    fi
  fi
  local ips=()

  if [[ -n "${ip_cmd}" ]]; then
    ips=("${(@f)$(
      "${ip_cmd}" -4 a 2>/dev/null |
        grep 'inet' |
        grep -Eo '([0-9]*\\.){3}[0-9]*' |
        grep -v '^127\\.' |
        grep -v '^169\\.254\\.' ||
        true
    )}")
  fi

  if [[ ${#ips[@]} -eq 0 ]] && command -v hostname >/dev/null 2>&1; then
    ips=("${(@f)$(
      hostname -I 2>/dev/null |
        tr ' ' '\n' |
        grep -Eo '([0-9]*\\.){3}[0-9]*' |
        grep -v '^127\\.' |
        grep -v '^169\\.254\\.' ||
        true
    )}")
  fi

  # Prefer non-172.* and non-100.* (same idea as bash prompt), but if that's all we have,
  # still show the first non-loopback address.
  local ip=""
  for ip in "${ips[@]}"; do
    [[ "${ip}" == 172.* ]] && continue
    [[ "${ip}" == 100.* ]] && continue
    print -r -- "${ip}"
    return 0
  done

  [[ ${#ips[@]} -gt 0 ]] && print -r -- "${ips[1]}"
}

dotfiles_prompt_precmd() {
  local exit_status=$?

  # Some terminal emulators respond to OSC queries (e.g. background color query OSC 11)
  # by writing escape sequences to the pty. If nothing consumes that response, zle can
  # treat it as typed input and it shows up as garbage after the prompt.
  # Flush pending bytes once per shell start (including slightly delayed responses after tmux attach).
  if [[ -z ${DOTFILES_STDIN_FLUSHED:-} ]]; then
    typeset -g DOTFILES_STDIN_FLUSHED=1
    local _dotfiles_discard=''
    local _dotfiles_steps=4
    local _dotfiles_step_wait=0.05
    [[ -n "${TMUX:-}" ]] && _dotfiles_steps=20

    local _dotfiles_i=0
    local _dotfiles_step=0
    for (( _dotfiles_step = 0; _dotfiles_step < _dotfiles_steps; _dotfiles_step++ )); do
      local _dotfiles_drained=0
      while read -rk 1 -t 0 _dotfiles_discard 2>/dev/null; do
        _dotfiles_drained=1
        (( _dotfiles_i++ > 2048 )) && break
      done

      if read -rk 1 -t "${_dotfiles_step_wait}" _dotfiles_discard 2>/dev/null; then
        _dotfiles_drained=1
        continue
      fi
      (( _dotfiles_drained == 1 )) || break
    done
  fi

  DOTFILES_PROMPT_PERMS="$(dotfiles_prompt_perms)"
  dotfiles_prompt_git
  [[ -n "${DOTFILES_PROMPT_IP}" ]] || DOTFILES_PROMPT_IP="$(dotfiles_prompt_ip)"

  DOTFILES_PROMPT_SSH=0
  [[ -n ${SSH_CONNECTION:-} || -n ${SSH_CLIENT:-} ]] && DOTFILES_PROMPT_SSH=1

  DOTFILES_PROMPT_SUDO=0
  [[ ${EUID} -ne 0 ]] && sudo -vn 2>/dev/null && DOTFILES_PROMPT_SUDO=1

  # Colors matching config/dotfiles.config (256-color palette)
  local bracket_color="${DOTFILES_PROMPT_BRACKET_COLOR:-39}"
  local color_bracket="%F{${bracket_color}}"
  local color_host='%F{39}'
  local color_dir='%F{214}'
  # Bash uses ANSI white (\e[37m) for separators like '@', ':' and parentheses.
  # In zsh prompt escapes, `%F{7}` is ANSI white, while `%F{37}` is 256-color index 37.
  local color_sep='%F{7}'
  local color_date='%F{83}'
  # Match bash git-prompt colors: label yellow, branch green, flags red.
  local color_git_label='%F{227}'
  # Use ANSI green (index 2) to match the common bash git-prompt branch green.
  local color_git_branch='%F{2}'
  # Use ANSI red (index 1) to match bash git-prompt status red.
  local color_git_flags='%F{1}'
  local color_ssh='%F{81}'
  local color_sudo='%F{99}'
  local color_user='%F{81}'
  local color_symbol='%F{7}'
  (( EUID == 0 )) && color_user='%F{196}' && color_symbol='%F{196}'

  local status_color='%F{39}'
  (( exit_status == 0 )) || status_color='%F{196}'

  # Line characters (Unicode). You can override these via environment variables.
  # NOTE: don't use `$'..'` in the env vars; put the actual characters in there.
  local lead="${DOTFILES_PROMPT_LEAD-}"
  local tail="${DOTFILES_PROMPT_TAIL-}"
  [[ -n "${lead}" ]] || lead=$'\u250c'         # ┌
  [[ -n "${tail}" ]] || tail=$'\u2514\u2500'   # └─

  local ssh_part=""
  (( DOTFILES_PROMPT_SSH == 1 )) && ssh_part="${color_ssh}ssh${color_sep}:"

  local ip_part=""
  if [[ -n "${DOTFILES_PROMPT_IP}" ]]; then
    ip_part="${color_sep} (%f${DOTFILES_PROMPT_IP}${color_sep})"
  fi

  local perms_part=""
  # Reset color before the opening "(" so it doesn't inherit the directory color.
  [[ -n "${DOTFILES_PROMPT_PERMS}" ]] && perms_part=" %f(${DOTFILES_PROMPT_PERMS})"

  local git_part=""
  if [[ -n "${DOTFILES_PROMPT_GIT_BRANCH}" ]]; then
    local git_tail=""
    if [[ -n "${DOTFILES_PROMPT_GIT_FLAGS}" || -n "${DOTFILES_PROMPT_GIT_UPSTREAM}" ]]; then
      git_tail=" ${color_git_flags}${DOTFILES_PROMPT_GIT_FLAGS}${DOTFILES_PROMPT_GIT_UPSTREAM}"
    fi
    git_part=" ${color_bracket}[${color_git_label}git:${color_git_branch}${DOTFILES_PROMPT_GIT_BRANCH}${git_tail}${color_bracket}]"
  fi

  local sudo_part=""
  (( DOTFILES_PROMPT_SUDO == 1 )) && sudo_part=" ${color_bracket}[${color_sudo}sudo${color_bracket}]"

  PROMPT=$'\n'
  PROMPT+="${status_color}${lead}${color_bracket}[${color_date}%D{%H:%M:%S}${color_bracket}] "
  PROMPT+="${color_bracket}[${ssh_part}${color_user}%n${color_sep}@${color_host}%m"
  PROMPT+="${ip_part}${color_sep}: ${color_dir}%~${perms_part}${color_bracket}]"
  PROMPT+="${git_part}${sudo_part}"
  PROMPT+=$'\n'
  PROMPT+="${status_color}${tail}${color_symbol}$ %f"
}

autoload -Uz add-zsh-hook
add-zsh-hook precmd dotfiles_prompt_precmd
