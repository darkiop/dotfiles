#!/bin/bash
# https://github.com/koljah-de/simple-bash-prompt/
# https://scriptim.github.io/bash-prompt-generator/
# https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html

# Set prompt colors
COLOR_BRACKET=${COLOR_BLUE}
#COLOR_COMMAND=${COLOR_WHITE}
COLOR_HOST=${COLOR_BLUE}
COLOR_DIR=${COLOR_ORANGE}
COLOR_SEPARATOR=${COLOR_WHITE}
COLOR_DATE=${COLOR_GREEN}
#COLOR_GIT=${COLOR_YELLOW}
COLOR_GIT_BRANCH=${COLOR_YELLOW}
COLOR_SUDO_ACTIVE=${COLOR_PURPLE}
COLOR_SSH_ACTIVE=${COLOR_LIGHT_BLUE}
if [[ ${EUID} -ne 0 ]]; then
	# User != root
	COLOR_USER=${COLOR_LIGHT_BLUE}
	COLOR_SYMBOL=${COLOR_WHITE}
else
	# User = root
	COLOR_USER=${COLOR_RED}
	COLOR_SYMBOL=${COLOR_RED}
fi

# Define the prompt terminator character
SYMBOL="\\$"

# Get the IP
IP=$(
	ip a | grep 'inet' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1' | grep -v '172' | grep -v '^100.' | head -n 1 || true
)

# Set the color with the exit status of the last command
function COLOR_EXIT_STATUS() {
	if [[ $1 -eq 0 ]]; then
		printf '%s' "${COLOR_BLUE}"
	else
		printf '%s' "${COLOR_RED}"
	fi
}

# Git: check if current directory is a git repo
function CHECK_IF_GIT_REPO() {
	git rev-parse --is-inside-work-tree >/dev/null 2>&1
}

# Git-prompt
# https://jon.sprig.gs/blog/post/1940
function GIT_PROMPT() {
	if ! command -v git >/dev/null 2>&1; then
		return 0
	fi
	if ! type __git_ps1 >/dev/null 2>&1; then
		return 0
	fi

	# options
	# https://blog.backslasher.net/git-prompt-variables.html
	export GIT_PS1_DESCRIBE_STYLE='contains'
	# __git_ps1 can emit unwrapped escape sequences when color hints are enabled,
	# which breaks readline redraws (e.g. when resizing the terminal).
	export GIT_PS1_SHOWCOLORHINTS='n'
	export GIT_PS1_SHOWDIRTYSTATE='y'
	export GIT_PS1_SHOWSTASHSTATE='y'
	export GIT_PS1_SHOWUNTRACKEDFILES='y'
	export GIT_PS1_SHOWUPSTREAM='auto'

	# prompt
	# https://stackoverflow.com/questions/25911546/configure-git-branch-in-prompt
	# staged = + stashed = $ untracked = %
	__git_ps1 'git:%s'
}

# check sudo
function CHECK_IF_SUDO_IS_ACTIVE() {
	if [[ ${EUID} -eq 0 ]]; then
		return 1 # false
	else
		if sudo -vn 2>/dev/null; then
			return 0 # true
		else
			return 1 # false
		fi
	fi
}

# Check if ssh session
function CHECK_IF_SSH_SESSION() {
	if [[ -n ${SSH_CONNECTION} || -n ${SSH_CLIENT} ]]; then
		return 0 # true
	else
		return 1 # false
	fi
}

# Show permissions of current directoy
# %A drwxr-xr-xr-x
# %a 755
function SHOW_PERMISSIONS_OF_CUR_DIR() {
	stat -c %a .
}

# Build the prompt
#
# \n = new line
# \u = user
# \h = time
# \w = current dir
#
function BUILD_PROMPT() {
	local exit_status=$?
	local git_part

	BASH_PROMPT="\n"
	BASH_PROMPT+="\[$(COLOR_EXIT_STATUS "${exit_status}")\]┌"
	BASH_PROMPT+="\[$COLOR_BRACKET\]["
	BASH_PROMPT+="\[$COLOR_DATE\]\\t"
	BASH_PROMPT+="\[$COLOR_BRACKET\]]"
	BASH_PROMPT+=" "
	BASH_PROMPT+="\[$COLOR_BRACKET\]["

	if CHECK_IF_SSH_SESSION; then
		BASH_PROMPT+="\[$COLOR_SSH_ACTIVE\]ssh\[$COLOR_SEPARATOR\]:"
	fi

	BASH_PROMPT+="\[$COLOR_USER\]\\u\[$COLOR_SEPARATOR\]@\[$COLOR_HOST\]\\h"
	if [[ -n ${IP} ]]; then
		BASH_PROMPT+="\[$COLOR_SEPARATOR\] (\[$COLOR_RESET\]${IP}\[$COLOR_SEPARATOR\])"
	fi
	BASH_PROMPT+="\[$COLOR_SEPARATOR\]: "
	BASH_PROMPT+="\[$COLOR_DIR\]\\w"
	BASH_PROMPT+="\[$COLOR_RESET\] ($(SHOW_PERMISSIONS_OF_CUR_DIR))"
	BASH_PROMPT+="\[$COLOR_BRACKET\]]"

	if CHECK_IF_GIT_REPO; then
		git_part="$(GIT_PROMPT)"
		if [[ -n ${git_part} ]]; then
			BASH_PROMPT+=" "
			BASH_PROMPT+="\[$COLOR_BRACKET\]["
			BASH_PROMPT+="\[$COLOR_GIT_BRANCH\]${git_part}"
			BASH_PROMPT+="\[$COLOR_BRACKET\]]"
		fi
	fi

	if CHECK_IF_SUDO_IS_ACTIVE; then
		BASH_PROMPT+=" "
		BASH_PROMPT+="\[$COLOR_BRACKET\]["
		BASH_PROMPT+="\[$COLOR_SUDO_ACTIVE\]sudo"
		BASH_PROMPT+="\[$COLOR_BRACKET\]]"
	fi

	BASH_PROMPT+="\n"
	BASH_PROMPT+="\[$(COLOR_EXIT_STATUS "${exit_status}")\]└─"
	BASH_PROMPT+="\[$COLOR_SYMBOL\]${SYMBOL} "
	BASH_PROMPT+="\[$COLOR_RESET\]"

	PS1=${BASH_PROMPT}
}

# Chain with any existing PROMPT_COMMAND (history sync, etc.) without duplicating.
case ";${PROMPT_COMMAND};" in
*";BUILD_PROMPT;"* | *"; BUILD_PROMPT;"*) ;;
*)
	if [[ -n ${PROMPT_COMMAND} ]]; then
		PROMPT_COMMAND="${PROMPT_COMMAND}; BUILD_PROMPT"
	else
		PROMPT_COMMAND="BUILD_PROMPT"
	fi
	;;
esac

export PROMPT_COMMAND
