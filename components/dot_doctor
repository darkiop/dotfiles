#!/bin/bash

_dot_doctor_print_row() {
	local check="$1"
	local status="$2"
	shift 2
	local info="$*"

	case "${_DOT_DOCTOR_SECTION:-Checks}" in
	Flags)
		_DOT_DOCTOR_FLAGS+=("${check}"$'\t'"${status}"$'\t'"${info}")
		;;
	System)
		_DOT_DOCTOR_SYSTEM+=("${check}"$'\t'"${status}"$'\t'"${info}")
		;;
	*)
		_DOT_DOCTOR_CHECKS+=("${check}"$'\t'"${status}"$'\t'"${info}")
		;;
	esac
}

_dot_doctor_ok() { _dot_doctor_print_row "$1" "OK" "$2"; }
_dot_doctor_warn() { _dot_doctor_print_row "$1" "WARN" "$2"; }
_dot_doctor_fail() { _dot_doctor_print_row "$1" "FAIL" "$2"; }

_dot_doctor_flag_enabled() {
	if command -v dotfiles_flag_enabled >/dev/null 2>&1; then
		dotfiles_flag_enabled "$1"
		return $?
	fi
	return 1
}

dot_doctor() {
	local DOTFILES_DIR="${HOME}/dotfiles"
	local repo_ok=true

	local use_color=0
	if [[ -t 1 ]] && [[ -z ${NO_COLOR:-} ]]; then
		use_color=1
	fi
	DOT_DOCTOR_C_RESET="${COLOR_RESET:-}"
	DOT_DOCTOR_C_HEAD="${COLOR_LIGHT_BLUE:-}"
	DOT_DOCTOR_C_MUTED="${COLOR_BLUE:-}"
	DOT_DOCTOR_C_OK="${COLOR_GREEN:-}"
	DOT_DOCTOR_C_WARN="${COLOR_YELLOW:-}"
	DOT_DOCTOR_C_FAIL="${COLOR_RED:-}"
	DOT_DOCTOR_C_INFO="${COLOR_LIGHT_BLUE:-}"
	if [[ ${use_color} -eq 1 ]] && [[ -z ${DOT_DOCTOR_C_RESET} ]]; then
		DOT_DOCTOR_C_HEAD=$'\033[36m'
		DOT_DOCTOR_C_MUTED=$'\033[34m'
		DOT_DOCTOR_C_OK=$'\033[32m'
		DOT_DOCTOR_C_WARN=$'\033[33m'
		DOT_DOCTOR_C_FAIL=$'\033[31m'
		DOT_DOCTOR_C_INFO=$'\033[36m'
		DOT_DOCTOR_C_RESET=$'\033[0m'
	fi

	_DOT_DOCTOR_CHECKS=()
	_DOT_DOCTOR_FLAGS=()
	_DOT_DOCTOR_SYSTEM=()
	_DOT_DOCTOR_SECTION="Checks"

	if [[ ! -d "${DOTFILES_DIR}" ]]; then
		_dot_doctor_fail "dotfiles dir" "${DOTFILES_DIR} missing"
		return 1
	fi
	if [[ ! -d "${DOTFILES_DIR}/.git" ]]; then
		_dot_doctor_fail "git repo" "${DOTFILES_DIR}/.git missing"
		repo_ok=false
	else
		_dot_doctor_ok "git repo" "${DOTFILES_DIR}"
	fi

	# Load feature flags if not already available (best-effort).
	if ! command -v dotfiles_flag_enabled >/dev/null 2>&1 && [[ -f "${DOTFILES_DIR}/components/feature_flags" ]]; then
		# shellcheck source=/dev/null
		source "${DOTFILES_DIR}/components/feature_flags" >/dev/null 2>&1 || true
	fi

	# Git status
	if ${repo_ok} && command -v git >/dev/null 2>&1; then
		local branch dirty_count
		branch="$(git -C "${DOTFILES_DIR}" branch --show-current 2>/dev/null || true)"
		branch="${branch:-unknown}"
		dirty_count="$(git -C "${DOTFILES_DIR}" status --porcelain=v1 2>/dev/null | wc -l | tr -d ' ')"
		if [[ ${dirty_count} -eq 0 ]]; then
			_dot_doctor_ok "git status" "clean (branch ${branch})"
		else
			_dot_doctor_warn "git status" "${dirty_count} changes (branch ${branch})"
		fi
	fi

	# Submodules
	if ${repo_ok} && command -v git >/dev/null 2>&1; then
		local sub_statuses
		sub_statuses="$(git -C "${DOTFILES_DIR}" submodule status --recursive 2>/dev/null | awk '{print $1}' || true)"
		if [[ -z ${sub_statuses} ]]; then
			_dot_doctor_warn "submodules" "unable to read status"
		elif printf '%s\n' "${sub_statuses}" | grep -q '^-'; then
			_dot_doctor_warn "submodules" "not initialized (run: git submodule update --init --recursive --depth 1)"
		elif printf '%s\n' "${sub_statuses}" | grep -q '^+'; then
			_dot_doctor_warn "submodules" "not up-to-date (run: git submodule update --init --recursive --depth 1)"
		elif printf '%s\n' "${sub_statuses}" | grep -q '^U'; then
			_dot_doctor_warn "submodules" "merge conflicts detected"
		else
			_dot_doctor_ok "submodules" "ok"
		fi
	fi

	# Symlinks
	_dot_doctor_check_link() {
		local target="$1"
		local expected="$2"
		local resolved=""

		_dot_doctor_resolve_path() {
			local path="$1"
			readlink -f -- "${path}" 2>/dev/null || true
		}
		resolved="$(_dot_doctor_resolve_path "${target}")"
		if [[ -z ${resolved} ]]; then
			if command -v greadlink >/dev/null 2>&1; then
				resolved="$(greadlink -f -- "${target}" 2>/dev/null || true)"
			elif command -v realpath >/dev/null 2>&1; then
				resolved="$(realpath "${target}" 2>/dev/null || true)"
			fi
		fi

		if [[ -L "${target}" ]]; then
			if [[ ${resolved} == "${expected}" ]]; then
				_dot_doctor_ok "link ${target##*/}" "ok"
			else
				_dot_doctor_warn "link ${target##*/}" "points to ${resolved:-unknown} (expected ${expected})"
			fi
		elif [[ -e "${target}" ]]; then
			_dot_doctor_warn "link ${target##*/}" "exists but is not a symlink"
		else
			_dot_doctor_warn "link ${target##*/}" "missing"
		fi
	}
	_dot_doctor_check_link "${HOME}/.bashrc" "${DOTFILES_DIR}/bashrc"
	_dot_doctor_check_link "${HOME}/.zshrc" "${DOTFILES_DIR}/zshrc"
	_dot_doctor_check_link "${HOME}/.tmux.conf" "${DOTFILES_DIR}/modules/oh-my-tmux/.tmux.conf"
	_dot_doctor_check_link "${HOME}/.tmux.conf.local" "${DOTFILES_DIR}/config/tmux.conf.local"

	# Binaries (based on enabled features)
	_DOT_DOCTOR_SECTION="Checks"
	_dot_doctor_need_bin() {
		local name="$1"
		local hint="$2"
		if command -v "${name}" >/dev/null 2>&1; then
			_dot_doctor_ok "bin ${name}" "ok"
		else
			_dot_doctor_warn "bin ${name}" "${hint}"
		fi
	}

	_dot_doctor_need_bin git "required"
	_dot_doctor_need_bin curl "required for installer"
	_dot_doctor_need_bin bash "required"
	_dot_doctor_need_bin zsh "optional"

	if _dot_doctor_flag_enabled DOTFILES_ENABLE_TMUX_AUTOSTART || _dot_doctor_flag_enabled DOTFILES_ENABLE_TMUX_FZF; then
		_dot_doctor_need_bin tmux "tmux enabled"
	fi
	if _dot_doctor_flag_enabled DOTFILES_ENABLE_FZF || _dot_doctor_flag_enabled DOTFILES_ENABLE_FZF_EXTRAS || _dot_doctor_flag_enabled DOTFILES_ENABLE_TMUX_FZF || _dot_doctor_flag_enabled DOTFILES_ENABLE_JOURNALCTL_PICKER || _dot_doctor_flag_enabled DOTFILES_ENABLE_GIT_FZF || _dot_doctor_flag_enabled DOTFILES_ENABLE_SYSTEMCTL_FZF || _dot_doctor_flag_enabled DOTFILES_ENABLE_DOCKER_FZF || _dot_doctor_flag_enabled DOTFILES_ENABLE_SSH_PICKER || _dot_doctor_flag_enabled DOTFILES_ENABLE_LOG_PICKER || _dot_doctor_flag_enabled DOTFILES_ENABLE_FZF_TAB_COMPLETION; then
		_dot_doctor_need_bin fzf "fzf enabled"
	fi
	if [[ -f "${DOTFILES_DIR}/motd/tasks.json" ]] || _dot_doctor_flag_enabled DOTFILES_ENABLE_DOT_HELP; then
		_dot_doctor_need_bin jq "required for motd/tasks.json"
	fi
	if _dot_doctor_flag_enabled DOTFILES_ENABLE_JOURNALCTL_PICKER; then
	_dot_doctor_need_bin journalctl "required for jctl"
	_dot_doctor_need_bin lnav "optional pager for jctl"
	fi

	# Feature flags summary (selected)
	if command -v dotfiles_flag_enabled >/dev/null 2>&1; then
		_DOT_DOCTOR_SECTION="Flags"
		local flags=(
			DOTFILES_ENABLE_PROMPT
			DOTFILES_ENABLE_FZF
			DOTFILES_ENABLE_FZF_EXTRAS
			DOTFILES_ENABLE_FZF_TAB_COMPLETION
			DOTFILES_ENABLE_GIT_FZF
			DOTFILES_ENABLE_HELPERS
			DOTFILES_ENABLE_MOTD
			DOTFILES_ENABLE_MOTD_AUTO_RUN
			DOTFILES_ENABLE_TMUX_AUTOSTART
			DOTFILES_ENABLE_TMUX_FZF
			DOTFILES_ENABLE_JOURNALCTL_PICKER
			DOTFILES_ENABLE_DOT_DOCTOR
		)
		local f enabled
		for f in "${flags[@]}"; do
			if dotfiles_flag_enabled "${f}"; then
				enabled="true"
			else
				enabled="false"
			fi
			_dot_doctor_print_row "flag ${f#DOTFILES_ENABLE_}" "INFO" "${enabled}"
		done
	fi

	# MOTD timers (systemd)
	if [[ -d /run/systemd/system ]] && command -v systemctl >/dev/null 2>&1; then
		_DOT_DOCTOR_SECTION="System"
		local enabled_a enabled_h
		enabled_a="$(systemctl is-enabled update-motd-apt-infos.timer 2>/dev/null || true)"
		enabled_h="$(systemctl is-enabled calc-dir-size-homes.timer 2>/dev/null || true)"
		_dot_doctor_print_row "motd timers" "INFO" "apt=${enabled_a:-unknown}, home=${enabled_h:-unknown}"
	fi

	# Render output in dot help --plain style
	_dot_doctor_print_section() {
		local section_name="$1"
		shift
		local -a items=("$@")
		local count=${#items[@]}
		local i=0

		printf '\n%b%s%b\n' "${DOT_DOCTOR_C_HEAD}" "${section_name}" "${DOT_DOCTOR_C_RESET}"
		for item in "${items[@]}"; do
			i=$((i + 1))
			local item_name item_status item_info status_color prefix
			IFS=$'\t' read -r item_name item_status item_info <<< "${item}"
			prefix="├─"
			[[ $i -eq $count ]] && prefix="╰─"
			case "${item_status}" in
				OK) status_color="${DOT_DOCTOR_C_OK}" ;;
				WARN) status_color="${DOT_DOCTOR_C_WARN}" ;;
				FAIL) status_color="${DOT_DOCTOR_C_FAIL}" ;;
				INFO) status_color="${DOT_DOCTOR_C_INFO}" ;;
				*) status_color="${DOT_DOCTOR_C_RESET}" ;;
			esac
			printf '%b%s%b %-28s %b%-7s%b %b%s%b\n' \
				"${DOT_DOCTOR_C_MUTED}" "${prefix}" "${DOT_DOCTOR_C_RESET}" \
				"${item_name}" \
				"${status_color}" "${item_status}" "${DOT_DOCTOR_C_RESET}" \
				"${DOT_DOCTOR_C_MUTED}" "${item_info}" "${DOT_DOCTOR_C_RESET}"
		done
	}

	# Box drawing characters
	local box_tl="╭" box_tr="╮" box_bl="╰" box_br="╯"
	local title="dot doctor"
	local box_width=50
	local padding=$(( (box_width - ${#title} - 2) ))
	local pad_left=$(( padding / 2 ))
	local pad_right=$(( padding - pad_left ))

	printf '%b%s' "${DOT_DOCTOR_C_MUTED}" "${box_tl}"
	printf '%0.s─' $(seq 1 $box_width)
	printf '%s%b\n' "${box_tr}" "${DOT_DOCTOR_C_RESET}"

	printf '%b%s%b' "${DOT_DOCTOR_C_MUTED}" "│" "${DOT_DOCTOR_C_RESET}"
	printf '%*s' "$pad_left" ""
	printf '%b%s%b' "${DOT_DOCTOR_C_HEAD}" " ${title} " "${DOT_DOCTOR_C_RESET}"
	printf '%*s' "$pad_right" ""
	printf '%b%s%b\n' "${DOT_DOCTOR_C_MUTED}" "│" "${DOT_DOCTOR_C_RESET}"

	printf '%b%s' "${DOT_DOCTOR_C_MUTED}" "${box_bl}"
	printf '%0.s─' $(seq 1 $box_width)
	printf '%s%b\n' "${box_br}" "${DOT_DOCTOR_C_RESET}"

	if [[ ${#_DOT_DOCTOR_CHECKS[@]} -gt 0 ]]; then
		_dot_doctor_print_section "Checks" "${_DOT_DOCTOR_CHECKS[@]}"
	fi
	if [[ ${#_DOT_DOCTOR_FLAGS[@]} -gt 0 ]]; then
		_dot_doctor_print_section "Flags" "${_DOT_DOCTOR_FLAGS[@]}"
	fi
	if [[ ${#_DOT_DOCTOR_SYSTEM[@]} -gt 0 ]]; then
		_dot_doctor_print_section "System" "${_DOT_DOCTOR_SYSTEM[@]}"
	fi

	printf '\n'
}
